/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
author: Nikolai Jonasson (https://sketchfab.com/nikolaijonasson)
license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
source: https://sketchfab.com/3d-models/female-marble-statue-polished-but-old-41b024813afd49fb827d942219d89b93
title: Female Marble Statue (Polished but old)
*/

import * as THREE from "three";
import { useRef } from "react";
import { useGLTF, useTexture, shaderMaterial, Float } from "@react-three/drei";
import { useFrame, extend, useThree } from "@react-three/fiber";
import CheckerboardFragment from "../components/shaders/checkerboard/fragment.glsl";
import CheckerboardVertex from "../components/shaders/checkerboard/vertex.glsl";
import MSDFTextGeometry from "../components/MSDFTextGeometry";
import MSDFTextMaterial from "../components/MSDFTextMaterial";
import uniforms from "../components/MSDFTextMaterial/uniforms";
import vertexShader from "../components/MSDFTextMaterial/shaders/vertex.glsl";
import fragmentShader from "../components/MSDFTextMaterial/shaders/fragment.glsl";
import { FontLoader } from "three-stdlib";
import { useControls } from "leva";

// import fnt from "../assets/fonts/ITCAvantGardeStd-Bold-msdf.json";
// import png from "../assets/fonts/ITCAvantGardeStd-Bold.png";

import fnt from "../assets/fonts/moderna-msdf.json";
import png from "../assets/fonts/moderna.png";

// import fnt from "../moderna-msdf.fnt"
// import png from "/moderna.png"

const CheckerboardShaderMaterial = shaderMaterial(
	{
		uTime: 0,
		lightPos: new THREE.Vector3(),
		cameraPos: new THREE.Vector3(),
		progress: 0,
	},
	CheckerboardVertex,
	CheckerboardFragment
);
extend({ CheckerboardShaderMaterial });

export function PepperfoxMSDF(props) {
	const camera = useThree((state) => state.camera);
	console.log("camera pos", camera);

	const checkerboardShaderMaterialRef = useRef();
	const pepperfoxMSDFRef = useRef();

	// console.log(femaleVibrantShaderMaterialRef.current)

	// useFrame((state, delta) => {
	// 	checkerboardShaderMaterialRef.current.uTime += delta;
	// 	checkerboardShaderMaterialRef.current.cameraPos = camera.position;
	// });

	const { lightPos } = { ...props };

	const { progress1, progress2, progress3, progress0 } = useControls({
		progress0: { value: 0.0, min: 0.0, max: 1.0 },
		progress1: { value: 0.0, min: 0.0, max: 1.0 },
		progress2: { value: 0.0, min: 0.0, max: 1.0 },
		progress3: { value: 0.0, min: 0.0, max: 1.0 },
	});

 const progressTest = 0.2


	Promise.all([loadFontAtlas(png)]).then(([atlas]) => {
		const geometry = new MSDFTextGeometry({
			text: "pepperfox",
			font: fnt,
		});

		console.log(geometry);

		// const options = {
		// 	side: THREE.FrontSide,
		// 	transparent: true,
		// 	defines: {
		// 		IS_SMALL: false,
		// 	},
		// 	extensions: {
		// 		derivatives: true,
		// 	},
		// 	uniforms: {
		// 		// Common
		// 		uOpacity: { value: 1 },
		// 		uColor: { value: new THREE.Color("#ffffff") },
		// 		uMap: { value: null },
		// 		// Rendering
		// 		uThreshold: { value: 0.05 },
		// 		uAlphaTest: { value: 0.01 },
		// 		// Strokes
		// 		uStrokeColor: { value: new THREE.Color("#ff0000") },
		// 		uStrokeOutsetWidth: { value: 0.0 },
		// 		uStrokeInsetWidth: { value: 0.3 },
		// 	},
		// 	vertexShader,
		// 	fragmentShader,
		// };

		// const material = new MSDFTextMaterial(options);

		const material = new THREE.ShaderMaterial({
			side: THREE.DoubleSide,
			transparent: true,
			defines: {
				IS_SMALL: false,
			},
			extensions: {
				derivatives: true,
			},
			uniforms: {
				// Common
				...uniforms.common,

				// Rendering
				...uniforms.rendering,

				// Strokes
				...uniforms.strokes,

				...{
					// uProgress0: { value: progress0 },
					// uProgress1: { value: progress1 },
					// uProgress2: { value: progress2 },
					// uProgress3: { value: progress3 },
					uStrokeColor: { value: new THREE.Color("#00ff00") },
				},
			},
			vertexShader: `
        // Attribute
        #include <three_msdf_attributes>

        // Varyings
        #include <three_msdf_varyings>

        void main() {
            #include <three_msdf_vertex>
        }
    `,
			fragmentShader: `
        // Varyings
        #include <three_msdf_varyings>
		
        // Uniforms
        #include <three_msdf_common_uniforms>
        #include <three_msdf_strokes_uniforms>
		
		uniform float uProgress0;
		uniform float uProgress1;
		uniform float uProgress2;
		uniform float uProgress3;

        // Utils
        #include <three_msdf_median>

		float rand(float n){return fract(sin(n) * 43758.5453123);}
		float rand(vec2 n) { 
			return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
		}

		float noise(float p){
			float fl = floor(p);
		float fc = fract(p);
			return mix(rand(fl), rand(fl + 1.0), fc);
		}
			
		float noise(vec2 n) {
			const vec2 d = vec2(0.0, 1.0);
		vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
			return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
		}

		float map(float value, float min1, float max1, float min2, float max2) {
		return min2 + (value - min1) * (max2 - min2) / (max1 - min1);
		}


        void main() {
            // Common
            #include <three_msdf_common>

            // Strokes
            #include <three_msdf_strokes>

            // Alpha Test
            #include <three_msdf_alpha_test>

			vec3 pink = vec3(0.634, 0.26, 0.780);

            // Outputs
            #include <three_msdf_strokes_output>

			vec4 l1 = vec4(1., 1., 1., border * 0.3);
			vec4 l2 = vec4(pink, border);
			vec4 l3 = vec4(pink, outset);
			vec4 l4 = vec4(vec3(1.), outset);
			
			float x = floor(vLayoutUv.x * 10. * 5.);
			float y = floor(vLayoutUv.y * 10.);
			float pattern = noise(vec2(x,y));
		  
			float w = 0.4;

			float p0 = uProgress0;
			p0 = map(p0, 0., 1., -w, 1.);
			p0 = smoothstep(p0,p0+w, vLayoutUv.x);
			float mix0 = 2.* p0 - pattern;
			mix0 = clamp(mix0, 0., 1.0 );

			
			float p1 = uProgress1;
			p1 = map(p1, 0., 1., -w, 1.);
			p1 = smoothstep(p1,p1+w, vLayoutUv.x);
			float mix1 = 2.* p1 - pattern;
			mix1 = clamp(mix1, 0., 1.0 );

			
			float p2 = uProgress2;
			p2 = map(p2, 0., 1., -w, 1.);
			p2 = smoothstep(p2,p2+w, vLayoutUv.x);
			float mix2 = 2.* p2 - pattern;
			mix2 = clamp(mix2, 0., 1.0 );

						
			float p3 = uProgress3;
			p3 = map(p3, 0., 1., -w, 1.);
			p3 = smoothstep(p3,p3+w, vLayoutUv.x);
			float mix3 = 2.* p3 - pattern;
			mix3 = clamp(mix3, 0., 1.0 );


			vec4 layer0 = mix(vec4(0.), l1, 1.-mix0);
			vec4 layer1 = mix(layer0, l2, 1.-mix1);
			vec4 layer2 = mix(layer1, l3, 1.-mix2);
			vec4 layer3 = mix(layer2, l4, 1.-mix3);


			vec4 layerFinal = vec4(0.);
			
		  
			gl_FragColor = vec4(1. * uProgress1, 0., 0., 1.);        
			gl_FragColor = l3;
			gl_FragColor = vec4(vec3(pattern), 1.);
			// gl_FragColor = vec4(vec3(p0_), 1.);
			gl_FragColor = layer3;
		
		
		}
    `,
		});
		material.uniforms.uMap.value = atlas;

		// material.uniforms.uMap.value = atlas;

		const mesh = new THREE.Mesh(geometry, material);
		pepperfoxMSDFRef.current.geometry = geometry;
		pepperfoxMSDFRef.current.material = material;
		pepperfoxMSDFRef.current.scale.set(0.004, 0.004, 0.004);
		pepperfoxMSDFRef.current.position.set(-0.4, -0, 0);
		pepperfoxMSDFRef.current.rotation.set(
			0,
			(180 * Math.PI) / 180,
			(180 * Math.PI) / 180
		);
	});

	function loadFontAtlas(path) {
		const promise = new Promise((resolve, reject) => {
			const loader = new THREE.TextureLoader();
			loader.load(path, resolve);
		});

		return promise;
	}

	// console.log(pepperfoxMSDFRef.current);

	return (
		<>
			<Float>
				<mesh ref={pepperfoxMSDFRef}>
					{/* <checkerboardShaderMaterial
						ref={checkerboardShaderMaterialRef}
						side={THREE.DoubleSide}
						lightPos={lightPos}
						// abstractTexture={abstractTexture}
						uProgress1={progress}
					/> */}
				</mesh>
			</Float>
			{/* <mesh>
				<planeGeometry args={[1, 1, 1]} />
				<checkerboardShaderMaterial
					ref={checkerboardShaderMaterialRef}
					side={THREE.DoubleSide}
					lightPos={lightPos}
					// abstractTexture={abstractTexture}
					progress={progress}
				/>
			</mesh> */}
		</>
	);
}
